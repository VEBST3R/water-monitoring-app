[
    {
        "id": "8cb51d754613f073",
        "type": "tab",
        "label": "Water Quality Monitoring Simulation",
        "disabled": false,
        "info": "Розширена симуляція пристроїв моніторингу якості води з технічними параметрами",
        "env": []
    },
    {
        "id": "init-simulation",
        "type": "inject",
        "z": "8cb51d754613f073",
        "name": "Initialize/Reset Simulation",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "true",
        "payloadType": "bool",
        "x": 690,
        "y": 400,
        "wires": [
            [
                "func-initialize-devices"
            ]
        ]
    },
    {
        "id": "func-initialize-devices",
        "type": "function",
        "z": "8cb51d754613f073",
        "name": "Setup Enhanced Device States & Configs",
        "func": "// Розширена ініціалізація пристроїв з технічними параметрами\nconst simulationStartTime = Date.now();\nflow.set('simulation_start_time', simulationStartTime);\n\nconst devices = {\n    \"111001\": {\n        name: 'Головний датчик',\n        customName: 'Головний датчик',\n        serverConfig: {\n            deviceId: '111001',\n            serverName: 'Локальний сервер (Node-RED)'\n        },\n        // Параметри якості води\n        baseline: { ph: 7.2, temp: 20, tds: 300, turbidity: 1.5 },\n        current: { ph: 7.2, temp: 20, tds: 300, turbidity: 1.5, wqi: 0, lastUpdate: Date.now() },\n        event: null,\n        // Технічні параметри для статусу пристрою\n        technical: {\n            powerSource: \"Від мережі\",\n            powerType: \"mains\", // mains, battery, solar\n            batteryLevel: 100, // відсотки\n            startTime: simulationStartTime,\n            lastCalibration: new Date('2025-05-15T10:30:00Z').getTime(),\n            calibrationInterval: 30 * 24 * 60 * 60 * 1000, // 30 днів у мілісекундах\n            sensorStatus: \"Всі датчики онлайн\",\n            connectionStatus: \"Стабільне\",\n            signalStrength: -35, // dBm\n            firmwareVersion: \"v2.1.3\",\n            hardwareVersion: \"v1.4\",\n            sensorHealth: {\n                ph: \"online\",\n                temperature: \"online\",\n                tds: \"online\",\n                turbidity: \"online\"\n            },\n            alerts: []\n        }\n    },\n    \"222002\": {\n        name: 'Резервний модуль',\n        customName: 'Резервний модуль',\n        serverConfig: {\n            deviceId: '222002',\n            serverName: 'Локальний сервер (Node-RED)'\n        },\n        baseline: { ph: 6.8, temp: 23, tds: 450, turbidity: 3.0 },\n        current: { ph: 6.8, temp: 23, tds: 450, turbidity: 3.0, wqi: 0, lastUpdate: Date.now() },\n        event: null,\n        technical: {\n            powerSource: \"Від батареї\",\n            powerType: \"battery\",\n            batteryLevel: 78,\n            startTime: simulationStartTime,\n            lastCalibration: new Date('2025-04-20T14:15:00Z').getTime(),\n            calibrationInterval: 30 * 24 * 60 * 60 * 1000,\n            sensorStatus: \"Всі датчики онлайн\",\n            connectionStatus: \"Стабільне\",\n            signalStrength: -52,\n            firmwareVersion: \"v2.0.8\",\n            hardwareVersion: \"v1.3\",\n            sensorHealth: {\n                ph: \"online\",\n                temperature: \"online\",\n                tds: \"online\",\n                turbidity: \"online\"\n            },\n            alerts: [\n                {\n                    id: \"alert_battery_low\",\n                    type: \"battery_warning\",\n                    severity: \"warning\",\n                    message: \"Рівень батареї нижче 80%\",\n                    timestamp: Date.now() - 3600000, // 1 година тому\n                    acknowledged: false\n                }\n            ]\n        }\n    },\n    \"333003\": {\n        name: 'Тестовий стенд',\n        customName: 'Тестовий стенд',\n        serverConfig: {\n            deviceId: '333003',\n            serverName: 'Локальний сервер (Node-RED)'\n        },\n        baseline: { ph: 5.5, temp: 28, tds: 600, turbidity: 7.0 },\n        current: { ph: 5.5, temp: 28, tds: 600, turbidity: 7.0, wqi: 0, lastUpdate: Date.now() },\n        event: null,\n        technical: {\n            powerSource: \"Сонячна батарея\",\n            powerType: \"solar\",\n            batteryLevel: 92,\n            startTime: simulationStartTime,\n            lastCalibration: new Date('2025-06-01T09:00:00Z').getTime(),\n            calibrationInterval: 30 * 24 * 60 * 60 * 1000,\n            sensorStatus: \"Попередження: датчик pH потребує калібрування\",\n            connectionStatus: \"Нестабільне\",\n            signalStrength: -67,\n            firmwareVersion: \"v1.9.2\",\n            hardwareVersion: \"v1.2\",\n            sensorHealth: {\n                ph: \"drift_detected\",\n                temperature: \"online\",\n                tds: \"online\",\n                turbidity: \"online\"\n            },\n            alerts: [\n                {\n                    id: \"alert_ph_drift\",\n                    type: \"sensor_drift\",\n                    severity: \"warning\",\n                    message: \"Виявлено дрейф датчика pH\",\n                    parameter: \"pH\",\n                    timestamp: Date.now() - 1800000, // 30 хвилин тому\n                    acknowledged: false\n                },\n                {\n                    id: \"alert_calibration_due\",\n                    type: \"calibration_needed\",\n                    severity: \"info\",\n                    message: \"Рекомендується калібрування датчиків\",\n                    timestamp: Date.now() - 7200000, // 2 години тому\n                    acknowledged: false\n                }\n            ]\n        }\n    }\n};\n\n// Функція розрахунку WQI та часткових балів\nfunction calculateParameterScores(params) {\n    let partial = {};\n    let totalWQI = 0;\n\n    // pH Score (target 6.5-8.5, optimal 7.0-7.6)\n    if (params.ph >= 7.0 && params.ph <= 7.6) partial.ph = 25;\n    else if (params.ph >= 6.5 && params.ph <= 8.5) partial.ph = 18;\n    else if (params.ph >= 6.0 && params.ph <= 9.0) partial.ph = 10;\n    else partial.ph = 5;\n    totalWQI += partial.ph;\n\n    // Temperature Score (target 15-25°C, optimal 18-22°C)\n    if (params.temp >= 18 && params.temp <= 22) partial.temp = 25;\n    else if (params.temp >= 15 && params.temp <= 25) partial.temp = 18;\n    else if (params.temp >= 10 && params.temp <= 30) partial.temp = 10;\n    else partial.temp = 5;\n    totalWQI += partial.temp;\n\n    // TDS Score (target < 500ppm, optimal < 300ppm)\n    if (params.tds <= 300) partial.tds = 25;\n    else if (params.tds <= 500) partial.tds = 18;\n    else if (params.tds <= 800) partial.tds = 10;\n    else partial.tds = 5;\n    totalWQI += partial.tds;\n\n    // Turbidity Score (target < 5 NTU, optimal < 1 NTU)\n    if (params.turbidity <= 1) partial.turbidity = 25;\n    else if (params.turbidity <= 5) partial.turbidity = 18;\n    else if (params.turbidity <= 10) partial.turbidity = 10;\n    else partial.turbidity = 5;\n    totalWQI += partial.turbidity;\n    \n    return { totalWQI: Math.max(0, Math.min(100, totalWQI)), partial: partial };\n}\n\n// Функція форматування часу роботи\nfunction formatOperatingTime(startTime) {\n    const now = Date.now();\n    const diffMs = now - startTime;\n    const hours = Math.floor(diffMs / (1000 * 60 * 60));\n    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));\n    return `${hours} год ${minutes} хв`;\n}\n\n// Функція перевірки статусу калібрування\nfunction getCalibrationStatus(lastCalibration, interval) {\n    const now = Date.now();\n    const daysSinceCalibration = (now - lastCalibration) / (1000 * 60 * 60 * 24);\n    const intervalDays = interval / (1000 * 60 * 60 * 24);\n    \n    if (daysSinceCalibration > intervalDays) {\n        return \"Потребує калібрування\";\n    } else if (daysSinceCalibration > intervalDays * 0.8) {\n        return \"Калібрування незабаром\";\n    }\n    return \"Актуальне\";\n}\n\n// Розрахунок початкових WQI для всіх пристроїв\nfor (const deviceId in devices) {\n    if (devices.hasOwnProperty(deviceId)) {\n        const params = devices[deviceId].current;\n        const scores = calculateParameterScores(params);\n        devices[deviceId].current.wqi = scores.totalWQI;\n        devices[deviceId].current.partial_scores = scores.partial;\n        \n        // Оновлення статусу калібрування\n        const calibrationStatus = getCalibrationStatus(\n            devices[deviceId].technical.lastCalibration,\n            devices[deviceId].technical.calibrationInterval\n        );\n        if (calibrationStatus !== \"Актуальне\") {\n            devices[deviceId].technical.sensorStatus = calibrationStatus;\n        }\n    }\n}\n\nflow.set('sim_devices', devices);\nflow.set('calculateWQI', calculateParameterScores);\nflow.set('formatOperatingTime', formatOperatingTime);\nflow.set('getCalibrationStatus', getCalibrationStatus);\n\nnode.status({ \n    fill: \"green\", \n    shape: \"dot\", \n    text: `Симуляція ініціалізована: ${Object.keys(devices).length} пристроїв` \n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 400,
        "wires": [
            [
                "debug-init"
            ]
        ]
    },
    {
        "id": "inject-update-tick",
        "type": "inject",
        "z": "8cb51d754613f073",
        "name": "Update Interval (7s)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "7",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 680,
        "y": 480,
        "wires": [
            [
                "func-update-all-device-states"
            ]
        ]
    },
    {
        "id": "func-update-all-device-states",
        "type": "function",
        "z": "8cb51d754613f073",
        "name": "Update All Device States & Technical Data",
        "func": "let devices = flow.get('sim_devices') || {};\nconst calculateWQI = flow.get('calculateWQI');\nconst formatOperatingTime = flow.get('formatOperatingTime');\n\nif (!calculateWQI) {\n    node.error(\"calculateWQI function not found in flow context\");\n    return null;\n}\n\nfor (const deviceId in devices) {\n    if (devices.hasOwnProperty(deviceId)) {\n        let device = devices[deviceId];\n        let baseline = device.baseline;\n        let current = device.current;\n        let technical = device.technical;\n\n        // Обробка поточних подій\n        if (device.event && device.event.duration > 0) {\n            device.event.duration -= 1;\n            // Застосування ефекту події\n            if (device.event.type === 'ph_drop') {\n                current.ph -= device.event.intensity * 0.2; \n            }\n            if (device.event.type === 'turbidity_spike') {\n                current.turbidity += device.event.intensity * 0.5;\n            }\n        } else {\n            device.event = null; // Очистити закінчену подію\n        }\n\n        // Симуляція нормальних флуктуацій або відновлення після події\n        // pH\n        let ph_target = (device.event && device.event.type === 'ph_drop') ? current.ph : baseline.ph;\n        current.ph += (ph_target - current.ph) * 0.1 + (Math.random() - 0.5) * 0.1;\n        current.ph = parseFloat(Math.max(0, Math.min(14, current.ph)).toFixed(2));\n\n        // Temperature\n        current.temp += (baseline.temp - current.temp) * 0.1 + (Math.random() - 0.5) * 0.5;\n        current.temp = parseFloat(Math.max(0, Math.min(40, current.temp)).toFixed(1));\n\n        // TDS\n        current.tds += (baseline.tds - current.tds) * 0.1 + (Math.random() - 0.5) * 20;\n        current.tds = Math.max(0, Math.min(2000, Math.floor(current.tds)));\n\n        // Turbidity\n        let turbidity_target = (device.event && device.event.type === 'turbidity_spike') ? current.turbidity : baseline.turbidity;\n        current.turbidity += (turbidity_target - current.turbidity) * 0.1 + (Math.random() - 0.5) * 0.3;\n        current.turbidity = parseFloat(Math.max(0, Math.min(50, current.turbidity)).toFixed(1));\n\n        // Симуляція технічних проблем (1% шанс кожний цикл)\n        if (Math.random() < 0.01) {\n            const problems = ['battery_drain', 'signal_weak', 'sensor_drift', 'connection_issue'];\n            const problem = problems[Math.floor(Math.random() * problems.length)];\n            \n            switch(problem) {\n                case 'battery_drain':\n                    if (technical.powerType === 'battery' || technical.powerType === 'solar') {\n                        technical.batteryLevel = Math.max(10, technical.batteryLevel - Math.floor(Math.random() * 5) - 1);\n                        if (technical.batteryLevel < 20) {\n                            technical.powerSource = technical.batteryLevel < 20 ? \n                                `${technical.powerSource} (${technical.batteryLevel}%)` : technical.powerSource;\n                        }\n                    }\n                    break;\n                case 'signal_weak':\n                    technical.signalStrength = Math.min(-80, technical.signalStrength - Math.floor(Math.random() * 15) - 5);\n                    technical.connectionStatus = technical.signalStrength < -70 ? \"Нестабільне\" : \"Стабільне\";\n                    break;\n                case 'sensor_drift':\n                    const sensors = ['ph', 'temperature', 'tds', 'turbidity'];\n                    const sensorToAffect = sensors[Math.floor(Math.random() * sensors.length)];\n                    technical.sensorHealth[sensorToAffect] = \"drift_detected\";\n                    technical.sensorStatus = `Попередження: датчик ${sensorToAffect.toUpperCase()} потребує калібрування`;\n                    break;\n                case 'connection_issue':\n                    technical.connectionStatus = \"Відключено\";\n                    break;\n            }\n        }\n\n        // Відновлення від проблем (5% шанс)\n        if (Math.random() < 0.05) {\n            // Відновлення сигналу\n            if (technical.signalStrength < -50) {\n                technical.signalStrength = Math.max(-45, technical.signalStrength + Math.floor(Math.random() * 10) + 5);\n                technical.connectionStatus = \"Стабільне\";\n            }\n            \n            // Відновлення сенсорів\n            const unhealthySensors = Object.keys(technical.sensorHealth).filter(s => technical.sensorHealth[s] !== 'online');\n            if (unhealthySensors.length > 0) {\n                const sensorToFix = unhealthySensors[Math.floor(Math.random() * unhealthySensors.length)];\n                technical.sensorHealth[sensorToFix] = 'online';\n                \n                // Перевірити, чи всі сенсори знову онлайн\n                const allOnline = Object.values(technical.sensorHealth).every(status => status === 'online');\n                if (allOnline) {\n                    technical.sensorStatus = \"Всі датчики онлайн\";\n                }\n            }\n        }\n\n        // Генерація нових випадкових подій (5% шанс)\n        if (!device.event && Math.random() < 0.05) {\n            if (Math.random() < 0.5) {\n                device.event = { \n                    type: 'ph_drop', \n                    duration: Math.floor(Math.random() * 5) + 3, \n                    intensity: Math.random() * 0.5 + 0.2 \n                };\n            } else {\n                device.event = { \n                    type: 'turbidity_spike', \n                    duration: Math.floor(Math.random() * 4) + 2, \n                    intensity: Math.random() * 2 + 1 \n                };\n            }\n        }\n        \n        // Оновлення WQI та часткових балів\n        const scores = calculateWQI(current);\n        current.wqi = scores.totalWQI;\n        current.partial_scores = scores.partial;\n        current.lastUpdate = Date.now();\n        \n        // Оновлення часу роботи\n        if (formatOperatingTime && technical.startTime) {\n            technical.operatingTime = formatOperatingTime(technical.startTime);\n        }\n        \n        // Перевірка необхідності калібрування\n        const now = Date.now();\n        const daysSinceCalibration = (now - technical.lastCalibration) / (1000 * 60 * 60 * 24);\n        const intervalDays = technical.calibrationInterval / (1000 * 60 * 60 * 24);\n        \n        if (daysSinceCalibration > intervalDays && !technical.alerts.some(a => a.type === 'calibration_overdue')) {\n            technical.alerts.push({\n                id: `alert_calibration_overdue_${Date.now()}`,\n                type: 'calibration_overdue',\n                severity: 'warning',\n                message: 'Калібрування прострочене',\n                timestamp: Date.now(),\n                acknowledged: false\n            });\n        }\n    }\n}\n\nflow.set('sim_devices', devices);\nnode.status({ \n    fill: \"blue\", \n    shape: \"dot\", \n    text: `Оновлено: ${new Date().toLocaleTimeString()}` \n});\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 480,
        "wires": [
            [
                "debug-update"
            ]
        ]
    },
    {
        "id": "http-in-getwqi-dynamic",
        "type": "http in",
        "z": "8cb51d754613f073",
        "name": "GET /getWQI",
        "url": "/getWQI",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 650,
        "y": 580,
        "wires": [
            [
                "func-get-device-data"
            ]
        ]
    },
    {
        "id": "func-get-device-data",
        "type": "function",
        "z": "8cb51d754613f073",
        "name": "Retrieve Device WQI Data",
        "func": "const deviceId = msg.req.query.device;\nconst devices = flow.get('sim_devices') || {};\n\nif (devices.hasOwnProperty(deviceId)) {\n    const device = devices[deviceId];\n    msg.payload = {\n        wqi: device.current.wqi,\n        parameters: {\n            pH: device.current.ph,\n            temperature: device.current.temp,\n            tds: device.current.tds,\n            turbidity: device.current.turbidity\n        },\n        partial_scores: device.current.partial_scores,\n        timestamp: new Date(device.current.lastUpdate).toISOString(),\n        deviceName: device.name\n    };\n    msg.statusCode = 200;\n} else {\n    msg.payload = {\n        error: \"Unknown device ID\",\n        received_device_id: deviceId,\n        available_devices: Object.keys(devices)\n    };\n    msg.statusCode = 404;\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 580,
        "wires": [
            [
                "http-response-dynamic"
            ]
        ]
    },
    {
        "id": "http-response-dynamic",
        "type": "http response",
        "z": "8cb51d754613f073",
        "name": "WQI Data Response",
        "statusCode": "",
        "headers": {
            "content-type": "application/json",
            "access-control-allow-origin": "*"
        },
        "x": 1130,
        "y": 580,
        "wires": []
    },
    {
        "id": "http-in-device-status",
        "type": "http in",
        "z": "8cb51d754613f073",
        "name": "GET /getDeviceStatus",
        "url": "/getDeviceStatus",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 650,
        "y": 660,
        "wires": [
            [
                "func-get-device-status"
            ]
        ]
    },
    {
        "id": "func-get-device-status",
        "type": "function",
        "z": "8cb51d754613f073",
        "name": "Retrieve Device Status & Technical Data",
        "func": "const deviceId = msg.req.query.device;\nconst devices = flow.get('sim_devices') || {};\n\nif (devices.hasOwnProperty(deviceId)) {\n    const device = devices[deviceId];\n    const tech = device.technical;\n    \n    // Форматування дати останнього калібрування\n    const lastCalibrationDate = new Date(tech.lastCalibration).toLocaleDateString('uk-UA', {\n        day: '2-digit',\n        month: '2-digit',\n        year: 'numeric'\n    });\n    \n    // Розрахунок часу роботи\n    const now = Date.now();\n    const diffMs = now - tech.startTime;\n    const hours = Math.floor(diffMs / (1000 * 60 * 60));\n    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));\n    const operatingTime = `${hours} год ${minutes} хв`;\n    \n    msg.payload = {\n        // Основна інформація про пристрій\n        deviceId: deviceId,\n        customName: device.customName,\n        serverConfig: device.serverConfig,\n        \n        // Технічні параметри для UI\n        powerSource: tech.powerSource,\n        operatingTime: operatingTime,\n        sensorStatus: tech.sensorStatus,\n        lastCalibrationDate: lastCalibrationDate,\n        \n        // Додаткові технічні дані\n        technical: {\n            powerType: tech.powerType,\n            batteryLevel: tech.batteryLevel,\n            connectionStatus: tech.connectionStatus,\n            signalStrength: tech.signalStrength,\n            firmwareVersion: tech.firmwareVersion,\n            hardwareVersion: tech.hardwareVersion,\n            sensorHealth: tech.sensorHealth,\n            alerts: tech.alerts || []\n        },\n        \n        timestamp: new Date().toISOString()\n    };\n    msg.statusCode = 200;\n} else {\n    msg.payload = {\n        error: \"Unknown device ID\",\n        received_device_id: deviceId,\n        available_devices: Object.keys(devices)\n    };\n    msg.statusCode = 404;\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 660,
        "wires": [
            [
                "http-response-device-status"
            ]
        ]
    },
    {
        "id": "http-response-device-status",
        "type": "http response",
        "z": "8cb51d754613f073",
        "name": "Device Status Response",
        "statusCode": "",
        "headers": {
            "content-type": "application/json",
            "access-control-allow-origin": "*"
        },
        "x": 1130,
        "y": 660,
        "wires": []
    },
    {
        "id": "http-in-calibrate",
        "type": "http in",
        "z": "8cb51d754613f073",
        "name": "POST /calibrateSensors",
        "url": "/calibrateSensors",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 650,
        "y": 740,
        "wires": [
            [
                "func-calibrate-sensors"
            ]
        ]
    },
    {
        "id": "func-calibrate-sensors",
        "type": "function",
        "z": "8cb51d754613f073",
        "name": "Perform Sensor Calibration",
        "func": "const devices = flow.get('sim_devices') || {};\nlet deviceId;\n\n// Отримання deviceId з query параметрів або body\nif (msg.req.query && msg.req.query.device) {\n    deviceId = msg.req.query.device;\n} else if (msg.payload && msg.payload.deviceId) {\n    deviceId = msg.payload.deviceId;\n} else {\n    msg.payload = {\n        success: false,\n        error: \"Device ID not provided\",\n        message: \"Вкажіть ID пристрою для калібрування\"\n    };\n    msg.statusCode = 400;\n    return msg;\n}\n\nif (devices.hasOwnProperty(deviceId)) {\n    const device = devices[deviceId];\n    const now = Date.now();\n    \n    // Симуляція процесу калібрування\n    device.technical.lastCalibration = now;\n    device.technical.sensorStatus = \"Всі датчики онлайн\";\n    \n    // Скидання проблем з датчиками\n    for (const sensor in device.technical.sensorHealth) {\n        device.technical.sensorHealth[sensor] = \"online\";\n    }\n    \n    // Очищення алертів про калібрування\n    device.technical.alerts = device.technical.alerts.filter(alert => \n        !['calibration_needed', 'calibration_overdue', 'sensor_drift'].includes(alert.type)\n    );\n    \n    // Додавання успішного аlerту про калібрування\n    device.technical.alerts.push({\n        id: `calibration_success_${now}`,\n        type: \"calibration_completed\",\n        severity: \"info\",\n        message: \"Калібрування успішно завершено\",\n        timestamp: now,\n        acknowledged: false\n    });\n    \n    // Збереження оновлених даних\n    flow.set('sim_devices', devices);\n    \n    const calibrationDate = new Date(now).toLocaleDateString('uk-UA', {\n        day: '2-digit',\n        month: '2-digit',\n        year: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n    });\n    \n    msg.payload = {\n        success: true,\n        message: \"Калібрування успішно завершено\",\n        deviceId: deviceId,\n        calibrationDate: calibrationDate,\n        affectedSensors: [\"pH\", \"температура\", \"TDS\", \"каламутність\"],\n        timestamp: new Date(now).toISOString()\n    };\n    msg.statusCode = 200;\n} else {\n    msg.payload = {\n        success: false,\n        error: \"Unknown device ID\",\n        received_device_id: deviceId,\n        available_devices: Object.keys(devices)\n    };\n    msg.statusCode = 404;\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 740,
        "wires": [
            [
                "http-response-calibrate"
            ]
        ]
    },
    {
        "id": "http-response-calibrate",
        "type": "http response",
        "z": "8cb51d754613f073",
        "name": "Calibration Response",
        "statusCode": "",
        "headers": {
            "content-type": "application/json",
            "access-control-allow-origin": "*"
        },
        "x": 1130,
        "y": 740,
        "wires": []
    },
    {
        "id": "http-in-listsensors-1717230000000",
        "type": "http in",
        "z": "8cb51d754613f073",
        "name": "GET /listAvailableSensors",
        "url": "/listAvailableSensors",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 650,
        "y": 820,
        "wires": [
            [
                "func-list-sensors-1717230000000"
            ]
        ]
    },
    {
        "id": "func-list-sensors-1717230000000",
        "type": "function",
        "z": "8cb51d754613f073",
        "name": "List Available Sensors",
        "func": "const devices = flow.get('sim_devices') || {};\nconst availableSensors = [];\n\nfor (const deviceId in devices) {\n    if (devices.hasOwnProperty(deviceId)) {\n        const device = devices[deviceId];\n        availableSensors.push({\n            id: deviceId,\n            name: device.name,\n            customName: device.customName,\n            serverConfig: device.serverConfig,\n            status: device.technical.connectionStatus,\n            lastUpdate: new Date(device.current.lastUpdate).toISOString()\n        });\n    }\n}\n\nmsg.payload = {\n    sensors: availableSensors,\n    totalCount: availableSensors.length,\n    timestamp: new Date().toISOString()\n};\nmsg.statusCode = 200;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 820,
        "wires": [
            [
                "http-response-listsensors-1717230000000"
            ]
        ]
    },
    {
        "id": "http-response-listsensors-1717230000000",
        "type": "http response",
        "z": "8cb51d754613f073",
        "name": "Sensor List Response",
        "statusCode": "",
        "headers": {
            "content-type": "application/json",
            "access-control-allow-origin": "*"
        },
        "x": 1130,
        "y": 820,
        "wires": []
    },
    {
        "id": "debug-init",
        "type": "debug",
        "z": "8cb51d754613f073",
        "name": "Debug: Initialization",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1280,
        "y": 400,
        "wires": []
    },
    {
        "id": "debug-update",
        "type": "debug",
        "z": "8cb51d754613f073",
        "name": "Debug: State Update",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 480,
        "wires": []
    },
    {
        "id": "inject-test-calibration",
        "type": "inject",
        "z": "8cb51d754613f073",
        "name": "Test Calibration (111001)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"deviceId\":\"111001\"}",
        "payloadType": "json",
        "x": 690,
        "y": 900,
        "wires": [
            [
                "func-calibrate-sensors"
            ]
        ]
    }
]
