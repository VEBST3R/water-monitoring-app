[{"id":"8cb51d754613f073","type":"tab","label":"Water Quality Monitoring Simulation","disabled":false,"info":"Розширена симуляція пристроїв моніторингу якості води з технічними параметрами","env":[]},{"id":"init-simulation","type":"inject","z":"8cb51d754613f073","name":"Initialize/Reset Simulation","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"true","payloadType":"bool","x":690,"y":400,"wires":[["func-initialize-devices"]]},{"id":"func-initialize-devices","type":"function","z":"8cb51d754613f073","name":"Setup Enhanced Device States & Configs","func":"// Розширена ініціалізація пристроїв з технічними параметрами\nconst simulationStartTime = Date.now();\nflow.set('simulation_start_time', simulationStartTime);\n\nconst devices = {\n    \"111001\": {\n        name: 'Головний датчик',\n        customName: 'Головний датчик',\n        serverConfig: {\n            deviceId: '111001',\n            serverName: 'Локальний сервер (Node-RED)'\n        },\n        isOnline: true,\n        location: 'Лабораторія',\n        // Параметри якості води\n        baseline: { ph: 7.2, temp: 20, tds: 300, turbidity: 1.5 },\n        current: { ph: 7.2, temp: 20, tds: 300, turbidity: 1.5, wqi: 0, lastUpdate: Date.now() },\n        event: null,\n        // Технічні параметри для статусу пристрою\n        technical: {\n            powerSource: \"Від мережі\",\n            powerType: \"mains\",\n            batteryLevel: 100,\n            startTime: simulationStartTime,\n            lastCalibration: new Date('2025-05-15T10:30:00Z').getTime(),\n            calibrationInterval: 30 * 24 * 60 * 60 * 1000,\n            sensorStatus: \"Всі датчики онлайн\",\n            connectionStatus: \"Стабільне\",\n            signalStrength: -35,\n            firmwareVersion: \"v2.1.3\",\n            hardwareVersion: \"v1.4\",\n            sensorHealth: {\n                ph: \"online\",\n                temperature: \"online\",\n                tds: \"online\",\n                turbidity: \"online\"\n            },\n            alerts: []\n        }\n    },\n    \"222002\": {\n        name: 'Резервний модуль',\n        customName: 'Резервний модуль',\n        serverConfig: {\n            deviceId: '222002',\n            serverName: 'Локальний сервер (Node-RED)'\n        },\n        isOnline: true,\n        location: 'Резерв',\n        baseline: { ph: 6.8, temp: 23, tds: 450, turbidity: 3.0 },\n        current: { ph: 6.8, temp: 23, tds: 450, turbidity: 3.0, wqi: 0, lastUpdate: Date.now() },\n        event: null,\n        technical: {\n            powerSource: \"Від батареї\",\n            powerType: \"battery\",\n            batteryLevel: 78,\n            startTime: simulationStartTime,\n            lastCalibration: new Date('2025-04-20T14:15:00Z').getTime(),\n            calibrationInterval: 30 * 24 * 60 * 60 * 1000,\n            sensorStatus: \"Всі датчики онлайн\",\n            connectionStatus: \"Стабільне\",\n            signalStrength: -52,\n            firmwareVersion: \"v2.0.8\",\n            hardwareVersion: \"v1.3\",\n            sensorHealth: {\n                ph: \"online\",\n                temperature: \"online\",\n                tds: \"online\",\n                turbidity: \"online\"\n            },\n            alerts: [\n                {\n                    id: \"alert_battery_low\",\n                    type: \"battery_warning\",\n                    severity: \"warning\",\n                    message: \"Рівень батареї нижче 80%\",\n                    timestamp: Date.now() - 3600000,\n                    acknowledged: false\n                }\n            ]\n        }\n    },\n    \"333003\": {\n        name: 'Тестовий стенд',\n        customName: 'Тестовий стенд',\n        serverConfig: {\n            deviceId: '333003',\n            serverName: 'Локальний сервер (Node-RED)'\n        },\n        isOnline: false,\n        location: 'Тестова зона',\n        baseline: { ph: 5.5, temp: 28, tds: 600, turbidity: 7.0 },\n        current: { ph: 5.5, temp: 28, tds: 600, turbidity: 7.0, wqi: 0, lastUpdate: Date.now() },\n        event: null,\n        technical: {\n            powerSource: \"Сонячна батарея\",\n            powerType: \"solar\",\n            batteryLevel: 92,\n            startTime: simulationStartTime,\n            lastCalibration: new Date('2025-06-01T09:00:00Z').getTime(),\n            calibrationInterval: 30 * 24 * 60 * 60 * 1000,\n            sensorStatus: \"Попередження: датчик pH потребує калібрування\",\n            connectionStatus: \"Нестабільне\",\n            signalStrength: -67,\n            firmwareVersion: \"v1.9.2\",\n            hardwareVersion: \"v1.2\",\n            sensorHealth: {\n                ph: \"drift_detected\",\n                temperature: \"online\",\n                tds: \"online\",\n                turbidity: \"online\"\n            },\n            alerts: [\n                {\n                    id: \"alert_ph_drift\",\n                    type: \"sensor_drift\",\n                    severity: \"warning\",\n                    message: \"Виявлено дрейф датчика pH\",\n                    parameter: \"pH\",\n                    timestamp: Date.now() - 1800000,\n                    acknowledged: false\n                }\n            ]\n        }\n    }\n};\n\n// Функція розрахунку WQI\nfunction calculateParameterScores(params) {\n    let partial = {};\n    let totalWQI = 0;\n    \n    // pH Score\n    if (params.ph >= 7.0 && params.ph <= 7.6) partial.ph = 25;\n    else if (params.ph >= 6.5 && params.ph <= 8.5) partial.ph = 18;\n    else if (params.ph >= 6.0 && params.ph <= 9.0) partial.ph = 10;\n    else partial.ph = 5;\n    totalWQI += partial.ph;\n    \n    // Temperature Score\n    if (params.temp >= 18 && params.temp <= 22) partial.temp = 25;\n    else if (params.temp >= 15 && params.temp <= 25) partial.temp = 18;\n    else if (params.temp >= 10 && params.temp <= 30) partial.temp = 10;\n    else partial.temp = 5;\n    totalWQI += partial.temp;\n    \n    // TDS Score\n    if (params.tds <= 300) partial.tds = 25;\n    else if (params.tds <= 500) partial.tds = 18;\n    else if (params.tds <= 800) partial.tds = 10;\n    else partial.tds = 5;\n    totalWQI += partial.tds;\n    \n    // Turbidity Score\n    if (params.turbidity <= 1) partial.turbidity = 25;\n    else if (params.turbidity <= 5) partial.turbidity = 18;\n    else if (params.turbidity <= 10) partial.turbidity = 10;\n    else partial.turbidity = 5;\n    totalWQI += partial.turbidity;\n    \n    return { totalWQI: Math.max(0, Math.min(100, totalWQI)), partial: partial };\n}\n\n// Функція форматування часу роботи\nfunction formatOperatingTime(startTime) {\n    const now = Date.now();\n    const diffMs = now - startTime;\n    const hours = Math.floor(diffMs / (1000 * 60 * 60));\n    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));\n    return `${hours} год ${minutes} хв`;\n}\n\n// Ініціалізація WQI\nfor (const deviceId in devices) {\n    if (devices.hasOwnProperty(deviceId)) {\n        const params = devices[deviceId].current;\n        const scores = calculateParameterScores(params);\n        devices[deviceId].current.wqi = scores.totalWQI;\n        devices[deviceId].current.partial_scores = scores.partial;\n        devices[deviceId].lastUpdate = new Date(params.lastUpdate).toLocaleString('uk-UA');\n    }\n}\n\nflow.set('sim_devices', devices);\nflow.set('calculateWQI', calculateParameterScores);\nflow.set('formatOperatingTime', formatOperatingTime);\n\nnode.status({ \n    fill: \"green\", \n    shape: \"dot\", \n    text: `Симуляція ініціалізована: ${Object.keys(devices).length} пристроїв` \n});\n\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":990,"y":400,"wires":[["debug-init"]]},{"id":"inject-update-tick","type":"inject","z":"8cb51d754613f073","name":"Update Interval (7s)","props":[{"p":"payload"}],"repeat":"7","crontab":"","once":true,"onceDelay":"1","topic":"","payload":"","payloadType":"date","x":680,"y":480,"wires":[["func-update-all-device-states"]]},{"id":"func-update-all-device-states","type":"function","z":"8cb51d754613f073","name":"Update All Device States & Technical Data","func":"let devices = flow.get('sim_devices') || {};\nconst calculateWQI = flow.get('calculateWQI');\nconst formatOperatingTime = flow.get('formatOperatingTime');\n\nif (!calculateWQI) {\n    node.error(\"calculateWQI function not found in flow context\");\n    return null;\n}\n\nfor (const deviceId in devices) {\n    if (devices.hasOwnProperty(deviceId)) {\n        let device = devices[deviceId];\n        let baseline = device.baseline;\n        let current = device.current;\n        let technical = device.technical;\n\n        // Симуляція нормальних флуктуацій\n        current.ph += (baseline.ph - current.ph) * 0.1 + (Math.random() - 0.5) * 0.1;\n        current.ph = parseFloat(Math.max(0, Math.min(14, current.ph)).toFixed(2));\n\n        current.temp += (baseline.temp - current.temp) * 0.1 + (Math.random() - 0.5) * 0.5;\n        current.temp = parseFloat(Math.max(0, Math.min(40, current.temp)).toFixed(1));\n\n        current.tds += (baseline.tds - current.tds) * 0.1 + (Math.random() - 0.5) * 20;\n        current.tds = Math.max(0, Math.min(2000, Math.floor(current.tds)));\n\n        current.turbidity += (baseline.turbidity - current.turbidity) * 0.1 + (Math.random() - 0.5) * 0.3;\n        current.turbidity = parseFloat(Math.max(0, Math.min(50, current.turbidity)).toFixed(1));\n        \n        // Оновлення WQI\n        const scores = calculateWQI(current);\n        current.wqi = scores.totalWQI;\n        current.partial_scores = scores.partial;\n        current.lastUpdate = Date.now();\n        \n        // Оновлення часу роботи\n        if (formatOperatingTime && technical.startTime) {\n            technical.operatingTime = formatOperatingTime(technical.startTime);\n        }\n        \n        // Оновлення онлайн статусу та часу останнього оновлення\n        device.isOnline = technical.connectionStatus !== \"Відключено\";\n        device.lastUpdate = new Date(current.lastUpdate).toLocaleString('uk-UA');\n    }\n}\n\nflow.set('sim_devices', devices);\nnode.status({ \n    fill: \"blue\", \n    shape: \"dot\", \n    text: `Оновлено: ${new Date().toLocaleTimeString()}` \n});\n\nreturn null;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":970,"y":480,"wires":[["debug-update"]]},{"id":"http-in-getwqi-dynamic","type":"http in","z":"8cb51d754613f073","name":"GET /getWQI","url":"/getWQI","method":"get","upload":false,"swaggerDoc":"","x":650,"y":580,"wires":[["func-get-device-data"]]},{"id":"func-get-device-data","type":"function","z":"8cb51d754613f073","name":"Retrieve Device WQI Data","func":"const deviceId = msg.req.query.device;\nconst devices = flow.get('sim_devices') || {};\n\nif (devices.hasOwnProperty(deviceId)) {\n    const device = devices[deviceId];\n    msg.payload = {\n        wqi: device.current.wqi,\n        parameters: {\n            pH: device.current.ph,\n            temperature: device.current.temp,\n            tds: device.current.tds,\n            turbidity: device.current.turbidity\n        },\n        partial_scores: device.current.partial_scores,\n        timestamp: new Date(device.current.lastUpdate).toISOString(),\n        deviceName: device.name\n    };\n    msg.statusCode = 200;\n} else {\n    msg.payload = {\n        error: \"Unknown device ID\",\n        received_device_id: deviceId,\n        available_devices: Object.keys(devices)\n    };\n    msg.statusCode = 404;\n}\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":900,"y":580,"wires":[["http-response-dynamic"]]},{"id":"http-response-dynamic","type":"http response","z":"8cb51d754613f073","name":"WQI Data Response","statusCode":"","headers":{"content-type":"application/json","access-control-allow-origin":"*"},"x":1130,"y":580,"wires":[]},{"id":"http-in-device-status","type":"http in","z":"8cb51d754613f073","name":"GET /getDeviceStatus","url":"/getDeviceStatus","method":"get","upload":false,"swaggerDoc":"","x":650,"y":660,"wires":[["func-get-device-status"]]},{"id":"func-get-device-status","type":"function","z":"8cb51d754613f073","name":"Retrieve Device Status & Technical Data","func":"const deviceId = msg.req.query.device;\nconst devices = flow.get('sim_devices') || {};\n\nif (devices.hasOwnProperty(deviceId)) {\n    const device = devices[deviceId];\n    const tech = device.technical;\n    \n    // Форматування дати останнього калібрування\n    const lastCalibrationDate = new Date(tech.lastCalibration).toLocaleDateString('uk-UA', {\n        day: '2-digit',\n        month: '2-digit',\n        year: 'numeric'\n    });\n    \n    msg.payload = {\n        // Основна інформація про пристрій\n        deviceId: deviceId,\n        name: device.name,\n        customName: device.customName,\n        serverConfig: device.serverConfig,\n        isOnline: device.isOnline,\n        location: device.location,\n        lastUpdate: device.lastUpdate,\n        \n        // Технічні параметри\n        technical: {\n            powerSource: tech.powerSource,\n            operatingTime: tech.operatingTime || \"0 год 0 хв\",\n            batteryLevel: tech.batteryLevel,\n            ping: Math.abs(tech.signalStrength) + Math.floor(Math.random() * 10),\n            firmwareVersion: tech.firmwareVersion,\n            lastCalibration: lastCalibrationDate,\n            sensorStatus: tech.sensorStatus,\n            alerts: tech.alerts || []\n        },\n        \n        timestamp: new Date().toISOString()\n    };\n    msg.statusCode = 200;\n} else {\n    msg.payload = {\n        error: \"Unknown device ID\",\n        received_device_id: deviceId,\n        available_devices: Object.keys(devices)\n    };\n    msg.statusCode = 404;\n}\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":900,"y":660,"wires":[["http-response-device-status"]]},{"id":"http-response-device-status","type":"http response","z":"8cb51d754613f073","name":"Device Status Response","statusCode":"","headers":{"content-type":"application/json","access-control-allow-origin":"*"},"x":1130,"y":660,"wires":[]},{"id":"http-in-calibrate","type":"http in","z":"8cb51d754613f073","name":"POST /calibrateSensors","url":"/calibrateSensors","method":"post","upload":false,"swaggerDoc":"","x":650,"y":740,"wires":[["func-calibrate-sensors"]]},{"id":"func-calibrate-sensors","type":"function","z":"8cb51d754613f073","name":"Perform Sensor Calibration","func":"const devices = flow.get('sim_devices') || {};\nlet deviceId;\n\n// Отримання deviceId з query параметрів або body\nif (msg.req.query && msg.req.query.device) {\n    deviceId = msg.req.query.device;\n} else if (msg.payload && msg.payload.deviceId) {\n    deviceId = msg.payload.deviceId;\n} else {\n    msg.payload = {\n        success: false,\n        error: \"Device ID not provided\",\n        message: \"Вкажіть ID пристрою для калібрування\"\n    };\n    msg.statusCode = 400;\n    return msg;\n}\n\nif (devices.hasOwnProperty(deviceId)) {\n    const device = devices[deviceId];\n    const now = Date.now();\n    \n    // Симуляція процесу калібрування\n    device.technical.lastCalibration = now;\n    device.technical.sensorStatus = \"Всі датчики онлайн\";\n    \n    // Скидання проблем з датчиками\n    for (const sensor in device.technical.sensorHealth) {\n        device.technical.sensorHealth[sensor] = \"online\";\n    }\n    \n    // Очищення алертів про калібрування\n    device.technical.alerts = device.technical.alerts.filter(alert => \n        !['calibration_needed', 'calibration_overdue', 'sensor_drift'].includes(alert.type)\n    );\n    \n    // Додавання успішного аlerту про калібрування\n    device.technical.alerts.push({\n        id: `calibration_success_${now}`,\n        type: \"calibration_completed\",\n        severity: \"info\",\n        message: \"Калібрування успішно завершено\",\n        timestamp: now,\n        acknowledged: false\n    });\n    \n    // Збереження оновлених даних\n    flow.set('sim_devices', devices);\n    \n    const calibrationDate = new Date(now).toLocaleDateString('uk-UA', {\n        day: '2-digit',\n        month: '2-digit',\n        year: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n    });\n    \n    msg.payload = {\n        success: true,\n        message: \"Калібрування успішно завершено\",\n        deviceId: deviceId,\n        calibrationDate: calibrationDate,\n        affectedSensors: [\"pH\", \"температура\", \"TDS\", \"каламутність\"],\n        timestamp: new Date(now).toISOString()\n    };\n    msg.statusCode = 200;\n} else {\n    msg.payload = {\n        success: false,\n        error: \"Unknown device ID\",\n        received_device_id: deviceId,\n        available_devices: Object.keys(devices)\n    };\n    msg.statusCode = 404;\n}\n\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":900,"y":740,"wires":[["http-response-calibrate"]]},{"id":"http-response-calibrate","type":"http response","z":"8cb51d754613f073","name":"Calibration Response","statusCode":"","headers":{"content-type":"application/json","access-control-allow-origin":"*"},"x":1130,"y":740,"wires":[]},{"id":"http-in-listsensors","type":"http in","z":"8cb51d754613f073","name":"GET /listAvailableSensors","url":"/listAvailableSensors","method":"get","upload":false,"swaggerDoc":"","x":650,"y":820,"wires":[["func-list-sensors"]]},{"id":"func-list-sensors","type":"function","z":"8cb51d754613f073","name":"List Available Sensors","func":"const devices = flow.get('sim_devices') || {};\nconst availableSensors = [];\n\nfor (const deviceId in devices) {\n    if (devices.hasOwnProperty(deviceId)) {\n        const device = devices[deviceId];\n        availableSensors.push({\n            id: deviceId,\n            name: device.name,\n            customName: device.customName,\n            serverConfig: device.serverConfig,\n            isOnline: device.isOnline,\n            status: device.technical.connectionStatus,\n            lastUpdate: new Date(device.current.lastUpdate).toISOString()\n        });\n    }\n}\n\nmsg.payload = {\n    sensors: availableSensors,\n    totalCount: availableSensors.length,\n    timestamp: new Date().toISOString()\n};\nmsg.statusCode = 200;\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":890,"y":820,"wires":[["http-response-listsensors"]]},{"id":"http-response-listsensors","type":"http response","z":"8cb51d754613f073","name":"Sensor List Response","statusCode":"","headers":{"content-type":"application/json","access-control-allow-origin":"*"},"x":1130,"y":820,"wires":[]},{"id":"debug-init","type":"debug","z":"8cb51d754613f073","name":"Debug: Initialization","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1280,"y":400,"wires":[]},{"id":"debug-update","type":"debug","z":"8cb51d754613f073","name":"Debug: State Update","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1270,"y":480,"wires":[]},{"id":"inject-test-calibration","type":"inject","z":"8cb51d754613f073","name":"Test Calibration (111001)","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"{\"deviceId\":\"111001\"}","payloadType":"json","x":670,"y":900,"wires":[["func-calibrate-sensors"]]}]